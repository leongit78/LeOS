print_hex:
    pusha ; сохраняем все регистры в стеке
    mov cx, 4 ; Счетчик цикла. Нам надо напечать 4 символа после 0x

char_loop:
    dec cx  ; декрементация счетчика

    mov ax, dx ; в ax хранится текущий выводимый символ
    shr dx, 4  ; смещаем dx на длину одного символа символа
    and ax, 0xf ; Изолируем текущий символ, обнуляя остальные

    mov bx, HEX_OUT ; Устанавливаем BX на адрес памяти нашей строки
    add bx, 2   ; Пропускаем первые два символа '0x'
    add bx, cx  ; пермещамся на текущий заполняемый элемент(зависит от счетчика) - изначально это послений элемент

    cmp ax, 0xa  ; Проверяем явлется текущий выводимый элемент числом или буквой
    jl set_letter ; Если число, то сразу идем устанавливать его в нашу строку
    add byte [bx], 7 ; Если буква, то берем байт по адресу, хранящемуся в BX, складывает значение этого байта с 7 и записывается результат туда же

    ; Добавляем 7 потому что от последней цифры до первой буквы в таблице ASCII расстояние 7 
    ; и чтобы его скомпенсировать мы и добавлем это расстояние

    ; Полное объяснение: код буквы, как и код цифры есть простое смещение относительно НУЛЯ(0x30 = 00110000 = '0')
    ; Но так как в таблице ASCII между цифрами и Заглавными латинскими буквами есть расстояние в 7 символов(там другие символы) 
    ; -> чтобы получить нужный код буквы неоюходимо учитывать это расстояние.
    ; Получается, в случае если очередной символ шестнадцатеричного числа, которое нам надо вывести это буква, то 
    ; мы сначала компенсируем расстояние м/у последней цифрой и первой буквой(прибавлем 7 к коду '0'), а потом прибавляем
    ; уже смещение этой буквы относительно нуля, если бы буквы шли сразу после цифр. 

    jmp set_letter

set_letter:
    add byte [bx], al ; Добавляем значение в al(код буквы/цифры) к символу в BX -> получаем в нужный ASCII код соотв символа в BX.   

    cmp cx, 0 ; Проверяем, не установили ли мы уже все символы
    je print_hex_done ; Если да, то выводим готовую строку на экран
    jmp char_loop  ; Если нет, то продолжаем - выполняем еще одну итерацию кода выше(char_loop)

print_hex_done:
    mov bx, HEX_OUT
    call print_string ; Функция печати строки

    popa ; Восстанавливаем все регистры из стека
    ret


HEX_OUT:
    db '0x0000', 0

%include "print_string.asm"